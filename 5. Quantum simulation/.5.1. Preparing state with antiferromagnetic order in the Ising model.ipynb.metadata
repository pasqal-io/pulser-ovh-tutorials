{"timestamp": 1698744635.205243, "stored_source_code": "# add default values for parameters here\n# Preparing a state with antiferromagnetic order in the Ising model\n\nThis notebook illustrates how to use Pulser to build a sequence for studying an antiferromagnetic state in an Ising-like model. It is based on [10.1103/PhysRevX.8.021070](https://journals.aps.org/prx/abstract/10.1103/PhysRevX.8.021070), where arrays of Rydberg atoms were programmed and whose correlations were studied.\n\nWe begin by importing some basic modules:\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport qutip\n\nfrom pulser import Pulse, Sequence, Register\nfrom pulser_simulation import QutipEmulator\nfrom pulser.waveforms import RampWaveform\nfrom pulser.devices import Chadoq2\n## Waveforms \n\nWe are realizing the following program\n\n<center>\n<img src=\"attachment:AF_Ising_program.png\" alt=\"AF Pulse Sequence\" width=\"300\">\n</center>\nThe pulse and the register are defined by the following parameters:\n# Parameters in rad/\u00b5s and ns\nOmega_max = 2.3 * 2 * np.pi\nU = Omega_max / 2.3\n\ndelta_0 = -6 * U\ndelta_f = 2 * U\n\nt_rise = 252\nt_fall = 500\nt_sweep = (delta_f - delta_0) / (2 * np.pi * 10) * 1000\n\nR_interatomic = Chadoq2.rydberg_blockade_radius(U)\n\nN_side = 3\nreg = Register.square(N_side, R_interatomic, prefix=\"q\")\nprint(f\"Interatomic Radius is: {R_interatomic}\u00b5m.\")\nreg.draw()\n## Creating my sequence\nWe compose our pulse with the following objects from Pulser:\nrise = Pulse.ConstantDetuning(\n    RampWaveform(t_rise, 0.0, Omega_max), delta_0, 0.0\n)\nsweep = Pulse.ConstantAmplitude(\n    Omega_max, RampWaveform(t_sweep, delta_0, delta_f), 0.0\n)\nfall = Pulse.ConstantDetuning(\n    RampWaveform(t_fall, Omega_max, 0.0), delta_f, 0.0\n)\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"ising\", \"rydberg_global\")\n\nseq.add(rise, \"ising\")\nseq.add(sweep, \"ising\")\nseq.add(fall, \"ising\")\n\nseq.draw()\n## Phase Diagram\nThe pulse sequence travels though the following path in the phase diagram of the system (the shaded area represents the antiferromagnetic phase):\ndelta = []\nomega = []\nfor x in seq._schedule[\"ising\"]:\n    if isinstance(x.type, Pulse):\n        omega += list(x.type.amplitude.samples / U)\n        delta += list(x.type.detuning.samples / U)\n\nfig, ax = plt.subplots()\nax.grid(True, which=\"both\")\n\nax.set_ylabel(r\"$\\hbar\\delta(t)/U$\", fontsize=16)\nax.set_xlabel(r\"$\\hbar\\Omega(t)/U$\", fontsize=16)\nax.set_xlim(0, 3)\nax.axhline(y=0, color=\"k\")\nax.axvline(x=0, color=\"k\")\n\ny = np.arange(0.0, 6, 0.01)\nx = 1.522 * (1 - 0.25 * (y - 2) ** 2)\nax.fill_between(x, y, alpha=0.4)\n\nax.plot(omega, delta, \"red\", lw=2)\nplt.show()\n## Simulation: Spin-Spin Correlation Function\nWe shall now evaluate the quality of the obtained state by calculating the *spin-spin correlation function*, defined as:\n\n\n$$g^c(k,l)= \\frac{1}{N_{k,l}}\\sum_{(i,j) = (kR,lR)} \\left[ \\langle n_i n_j \\rangle - \\langle n_i \\rangle \\langle n_j \\rangle \\right]$$\n\nwhere the $c$ indicates that we are calculating the *connected* part, and where the sum is over all pairs $(i,j)$ whose distance is ${\\bf r}_i - {\\bf r}_j = (k R,l R)$ in the atomic array coordinate (both $k$ and $l$ are positive or negative integers within the size of the array).\n\nWe run a simulation of the sequence:\nsimul = QutipEmulator.from_sequence(seq, sampling_rate=0.02)\nresults = simul.run(progress_bar=True)\nSample from final state using `sample_final_state()` method:\ncount = results.sample_final_state()\n\nmost_freq = {k: v for k, v in count.items() if v > 10}\nplt.bar(list(most_freq.keys()), list(most_freq.values()))\nplt.xticks(rotation=\"vertical\")\nplt.show()\nThe observable to measure will be the occupation operator $|r\\rangle \\langle r|_i$ on each site $i$ of the register, where the Rydberg state $|r\\rangle$ represents the excited state.\ndef occupation(j, N):\n    up = qutip.basis(2, 0)\n    prod = [qutip.qeye(2) for _ in range(N)]\n    prod[j] = up * up.dag()\n    return qutip.tensor(prod)\noccup_list = [occupation(j, N_side * N_side) for j in range(N_side * N_side)]\nWe define a function that returns all couples $(i,j)$ for a given $(k,l)$:\ndef get_corr_pairs(k, l, register, R_interatomic):\n    corr_pairs = []\n    for i, qi in enumerate(register.qubits):\n        for j, qj in enumerate(register.qubits):\n            r_ij = register.qubits[qi] - register.qubits[qj]\n            distance = np.linalg.norm(r_ij - R_interatomic * np.array([k, l]))\n            if distance < 1:\n                corr_pairs.append([i, j])\n    return corr_pairs\nThe correlation function is calculated with the following routines:\ndef get_corr_function(k, l, reg, R_interatomic, state):\n    N_qubits = len(reg.qubits)\n    corr_pairs = get_corr_pairs(k, l, reg, R_interatomic)\n\n    operators = [occupation(j, N_qubits) for j in range(N_qubits)]\n    covariance = 0\n    for qi, qj in corr_pairs:\n        covariance += qutip.expect(operators[qi] * operators[qj], state)\n        covariance -= qutip.expect(operators[qi], state) * qutip.expect(\n            operators[qj], state\n        )\n    return covariance / len(corr_pairs)\n\n\ndef get_full_corr_function(reg, state):\n    N_qubits = len(reg.qubits)\n\n    correlation_function = {}\n    N_side = int(np.sqrt(N_qubits))\n    for k in range(-N_side + 1, N_side):\n        for l in range(-N_side + 1, N_side):\n            correlation_function[(k, l)] = get_corr_function(\n                k, l, reg, R_interatomic, state\n            )\n    return correlation_function\nWith these functions, we operate on the final state of evolution obtained by our simulation.\nfinal = results.states[-1]\ncorrelation_function = get_full_corr_function(reg, final)\nexpected_corr_function = {}\nxi = 1  # Estimated Correlation Length\nfor k in range(-N_side + 1, N_side):\n    for l in range(-N_side + 1, N_side):\n        kk = np.abs(k)\n        ll = np.abs(l)\n        expected_corr_function[(k, l)] = (-1) ** (kk + ll) * np.exp(\n            -np.sqrt(k**2 + l**2) / xi\n        )\nA = 4 * np.reshape(\n    list(correlation_function.values()), (2 * N_side - 1, 2 * N_side - 1)\n)\nA = A / np.max(A)\nB = np.reshape(\n    list(expected_corr_function.values()), (2 * N_side - 1, 2 * N_side - 1)\n)\nB = B * np.max(A)\n\nfor i, M in enumerate([A.copy(), B.copy()]):\n    M[N_side - 1, N_side - 1] = None\n    plt.figure(figsize=(3.5, 3.5))\n    plt.imshow(M, cmap=\"coolwarm\", vmin=-0.6, vmax=0.6)\n    plt.xticks(range(len(M)), [f\"{x}\" for x in range(-N_side + 1, N_side)])\n    plt.xlabel(r\"$\\mathscr{k}$\", fontsize=22)\n    plt.yticks(range(len(M)), [f\"{-y}\" for y in range(-N_side + 1, N_side)])\n    plt.ylabel(r\"$\\mathscr{l}$\", rotation=0, fontsize=22, labelpad=10)\n    plt.colorbar(fraction=0.047, pad=0.02)\n    if i == 0:\n        plt.title(\n            r\"$4\\times\\.g^{(2)}(\\mathscr{k},\\mathscr{l})$ after simulation\",\n            fontsize=14,\n        )\n    if i == 1:\n        plt.title(\n            r\"Exponential $g^{(2)}(\\mathscr{k},\\mathscr{l})$ expected\",\n            fontsize=14,\n        )\n    plt.show()\nNote that the correlation function would follow an exponential decay (modulo finite-size effects), which is best observed at larger system sizes (see for example https://arxiv.org/pdf/2012.12268.pdf)\nnp.around(A, 4)\nnp.around(B, 4)\n### N\u00e9el Structure Factor\nOne way to explore the $\\Omega = 0$ line on the phase diagram is to calculate the *N\u00e9el Structure Factor*, $S_{\\text{N\u00e9el}}=4 \\times \\sum_{(k,l) \\neq (0,0)} (-1)^{|k|+|l|} g^c(k,l)$, which should be highest when the state is more antiferromagnetic. We will sweep over different values of $\\delta_{\\text{final}}$ to show that the region $0<\\hbar \\delta_{\\text{final}}/U<4$ is indeed where the antiferromagnetic phase takes place.\ndef get_neel_structure_factor(reg, R_interatomic, state):\n    N_qubits = len(reg.qubits)\n    N_side = int(np.sqrt(N_qubits))\n\n    st_fac = 0\n    for k in range(-N_side + 1, N_side):\n        for l in range(-N_side + 1, N_side):\n            kk = np.abs(k)\n            ll = np.abs(l)\n            if not (k == 0 and l == 0):\n                st_fac += (\n                    4\n                    * (-1) ** (kk + ll)\n                    * get_corr_function(k, l, reg, R_interatomic, state)\n                )\n    return st_fac\ndef calculate_neel(det, N, Omega_max=2.3 * 2 * np.pi):\n    # Setup:\n    U = Omega_max / 2.3\n    delta_0 = -6 * U\n    delta_f = det * U\n\n    t_rise = 252\n    t_fall = 500\n    t_sweep = int((delta_f - delta_0) / (2 * np.pi * 10) * 1000)\n    t_sweep += (\n        4 - t_sweep % 4\n    )  # To be a multiple of the clock period of Chadoq2 (4ns)\n\n    R_interatomic = Chadoq2.rydberg_blockade_radius(U)\n    reg = Register.rectangle(N, N, R_interatomic)\n\n    # Pulse Sequence\n    rise = Pulse.ConstantDetuning(\n        RampWaveform(t_rise, 0.0, Omega_max), delta_0, 0.0\n    )\n    sweep = Pulse.ConstantAmplitude(\n        Omega_max, RampWaveform(t_sweep, delta_0, delta_f), 0.0\n    )\n    fall = Pulse.ConstantDetuning(\n        RampWaveform(t_fall, Omega_max, 0.0), delta_f, 0.0\n    )\n\n    seq = Sequence(reg, Chadoq2)\n    seq.declare_channel(\"ising\", \"rydberg_global\")\n    seq.add(rise, \"ising\")\n    seq.add(sweep, \"ising\")\n    seq.add(fall, \"ising\")\n\n    simul = QutipEmulator.from_sequence(seq, sampling_rate=0.2)\n    results = simul.run()\n\n    final = results.states[-1]\n    return get_neel_structure_factor(reg, R_interatomic, final)\nN_side = 3\noccup_list = [occupation(j, N_side * N_side) for j in range(N_side * N_side)]\n\ndetunings = np.linspace(-1, 5, 20)\nresults = []\nfor det in detunings:\n    print(f\"Detuning = {np.round(det,3)} x 2\u03c0 Mhz.\")\n    results.append(calculate_neel(det, N_side))\nplt.xlabel(r\"$\\hbar\\delta_{final}/U$\")\nplt.ylabel(r\"N\u00e9el Structure Factor $S_{Neel}$\")\nplt.plot(detunings, results, \"o\", ls=\"solid\")\nplt.show()\nmax_index = results.index(max(results))\nprint(\n    f\"Max S_Neel {np.round(max(results),2)} at detuning = {np.round(detunings[max_index],2)} x 2\u03c0 Mhz.\"\n)", "params": {}}