{"timestamp": 1698744653.318673, "stored_source_code": "# add default values for parameters here\n# Effective noise channels\n## Introduction\n\nEffective noise channels were introduced in the introductory tutorial [Simulating sequences with errors and noises](noisy_sim.nblink). They will be further detailed in this notebook. We recommend you to check the introductory tutorial before going through this one.\n\nThe effective noise channels implemented here are based on the concept of Kraus operators which are actors in the Lindblad equation. If you're not familiar with Lindblad equations or want to go further, please check the resource [here](https://ocw.mit.edu/courses/22-51-quantum-theory-of-radiation-interactions-fall-2012/resources/mit22_51f12_ch8/).\n\nRecall the Lindblad equation:\n\n$$\n\\frac{d \\rho}{dt} = -i[\\mathcal{H}, \\rho] + \\sum_k \\left( L_k \\rho L_k^\\dagger - \\frac{1}{2} \\left\\{ L_k^\\dagger L_k, \\rho \\right\\} \\right)\n$$ \n\nThe operators $L_k$ are often called *collapse operators*. Basically, an effective noise channel can be fully described by a set of collapse operators that are related to each other by the completeness relation:  $\\sum_k L_k L_k^\\dagger = \\mathbb{I}$.\n\nSo varying $L_k$ gives birth to different effective noise channels. We will discuss in this tutorial two specific ones:\n\n* [The dephasing channel](#The-dephasing-channel)\n* [The depolarizing channel](#The-depolarizing-channel)\n\nfrom __future__ import annotations\n\nimport qutip\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom copy import deepcopy\nfrom pulser import Pulse, Sequence, Register\nfrom pulser_simulation import QutipEmulator, SimConfig\nfrom pulser_simulation.simresults import SimulationResults\nfrom pulser.devices import Chadoq2\n### The dephasing channel\n_Dephasing channel_ models noises that modify the system into a mixture of states such that the phase cannot be accurately predicted.\n\nThe dephasing noise can be thought of as arising from random z-rotations across the state, with a certain probability $p$. This can be modelled as the action of the following operators:\n\n$$\nL_0 = \\sqrt{1-\\frac{p}{2}} \\,\\, \\mathbb{I} \\\\\nL_1 = \\sqrt{\\frac{p}{2}} \\,\\, \\sigma_z\n$$\n### The depolarizing channel\nUnder the depolarizing noise, a system in any state evolves to the maximally mixed state. The correspoding collapse operators are:\n\n$$\nL_0 = \\sqrt{1-\\frac{3}{4}p} \\,\\, \\mathbb{I}, \\\\\nL_1 = \\sqrt{\\frac{p}{4}} \\sigma_x, \\\\\nL_2 = \\sqrt{\\frac{p}{4}}\\sigma_z, \\\\\nL_3 = \\sqrt{\\frac{p}{4}} \\sigma_y\n$$\n\n### Bloch sphere representation\nTo better understand the effect of each channel on a single-qubit density matrix, let us represent it on the Bloch sphere.\n\nAny density matrix of a mixed state may be written as $\\rho = \\frac{\\mathbb{I} + \\vec{r}.\\vec{\\sigma}}{2}$, where $\\vec{r}$ is the vector representing the mixed state on the Bloch sphere.\ndef vector_to_dm(r_x, r_y, r_z):\n    \"\"\"Transforms a vector on the Bloch sphere into a density matrix.\"\"\"\n\n    return 0.5 * (\n        qutip.qeye(2)\n        + r_x * qutip.sigmax()\n        + r_y * qutip.sigmay()\n        + r_z * qutip.sigmaz()\n    )\n\n\ndef dm_to_vector(rho):\n    \"\"\"Transforms a density matrix rho to vector on the Bloch sphere.\"\"\"\n\n    I = 2 * rho - np.eye(2)\n    r_x = np.real((I[0, 1] + I[1, 0]) / 2)\n    r_y = np.real((I[1, 0] - I[0, 1]) / 2)\n    r_z = np.real(I[0, 0])\n\n    return r_x, r_y, r_z\n\n\ndef depolarizing_channel(rho, prob):\n    \"\"\"Depolarizing channel.\"\"\"\n    return (1 - 3 * prob / 4) * rho + prob / 4 * (\n        qutip.sigmax() * rho * qutip.sigmax()\n        + qutip.sigmay() * rho * qutip.sigmay()\n        + qutip.sigmaz() * rho * qutip.sigmaz()\n    )\n\n\ndef dephasing_channel(rho, prob):\n    \"\"\"Dephasing channel.\"\"\"\n    return (\n        1 - prob / 2\n    ) * rho + prob / 2 * qutip.sigmaz() * rho * qutip.sigmaz()\nFirst, we generate uniformly distributed points on the surface of the Bloch sphere.\nu = np.linspace(0, 2 * np.pi, 20)\nv = np.linspace(0, np.pi, 20)\nr = 1\nn = len(u)\n# x, y, z coordinates with fixed radius r from center X0, Y0, Z0\n\nx = r * np.reshape(np.outer(np.cos(u), np.sin(v)), newshape=(n**2, 1))\ny = r * np.reshape(np.outer(np.sin(u), np.sin(v)), newshape=(n**2, 1))\nz = r * np.reshape(\n    np.outer(np.ones(np.size(u)), np.cos(v)), newshape=(n**2, 1)\n)\n\n# Then we build the bloch with the above points\nb = qutip.Bloch()\npoints = [x, y, z]\nb.add_points(points)\nb\nTo observe the effect of the depolarizing and dephasing channels, we apply each channel separately to the points on the Bloch sphere and plot the resulting vectors.\n#### Dephasing channel\ndephasing_prob = 0.5\nx_dp = x.copy()\ny_dp = y.copy()\nz_dp = z.copy()\nn, p = x.shape\nfor i in range(n):\n    for j in range(p):\n        dm = vector_to_dm(x[i, j], y[i, j], z[i, j])\n        dm_n = dephasing_channel(dm, dephasing_prob)\n        r_x, r_y, r_z = dm_to_vector(dm_n)\n        x_dp[i, j] = r_x\n        y_dp[i, j] = r_y\n        z_dp[i, j] = r_z\nb = qutip.Bloch()\npoints = [x_dp, y_dp, z_dp]\nb.add_points(points)\nb\nFor the dephasing channel, the $z$-coordinate of the Bloch vector is conserved while the others are contracted.\n#### Depolarizing channel\ndepolarizing_prob = 0.5\nx_dp = x.copy()\ny_dp = y.copy()\nz_dp = z.copy()\nn, p = x.shape\nfor i in range(n):\n    for j in range(p):\n        dm = vector_to_dm(x[i, j], y[i, j], z[i, j])\n        dm_n = depolarizing_channel(dm, depolarizing_prob)\n        r_x, r_y, r_z = dm_to_vector(dm_n)\n        x_dp[i, j] = r_x\n        y_dp[i, j] = r_y\n        z_dp[i, j] = r_z\nb = qutip.Bloch()\npoints = [x_dp, y_dp, z_dp]\nb.add_points(points)\nb\nThe depolarizing channel contracts the Bloch sphere across all directions. We could try to come up with an inflation channel that would revert the state's depolarization. However, such a channel would not be positive and thus not a valid superoperator, confirming that the coherence lost cannot be recovered.\n## Single atom noisy simulations\nIn this section we will study the impact of effective noise channels on a single qubit under a resonant pulse. We start by preparing a single atom:\nreg = Register.from_coordinates([(0, 0)], prefix=\"q\")\nThen we act on this atom with a Constant Pulse, such that it oscillates between the ground state and excited Rydberg state (Rabi oscillations):\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"channel 0\", \"rydberg_global\")\nduration = 10000\npulse = Pulse.ConstantPulse(duration, 2 * np.pi, 0 * np.pi, 0.0)\nseq.add(pulse, \"channel 0\")\nseq.draw()\nLet's first run the simulation without noise.\nclean_simu = QutipEmulator.from_sequence(seq, sampling_rate=0.05)\nclean_res = clean_simu.run()\nWe can observe the ground state population using its projector and then the `plot()` method from the `Results` object:\nobs = (\n    clean_simu.initial_state.proj()\n)  # Make projector from initial state of the QutipEmulator object (uses QuTiP)\nclean_res.plot(obs)  # Plot the expectation value of the observable\nplt.ylabel(\"Ground state population\")\nplt.show()\nThe are two ways to define the dephasing and depolarizing channels. The first way is to create a `SimConfig` object, specifying the noise type as `\"dephasing\"` and choosing the dephasing probability `dephasing_prob`:\nconfig_dephasing = SimConfig(noise=\"dephasing\", dephasing_prob=0.1)\nclean_simu.set_config(config_dephasing)\nclean_simu.show_config()\nLikewise we can create a SimConfig object for the depolarizing noise. Notice how we reset the configuration using the `reset_config()` method:\nclean_simu.reset_config()\nconfig_depolarizing = SimConfig(noise=\"depolarizing\", depolarizing_prob=0.1)\nclean_simu.set_config(config_depolarizing)\nclean_simu.show_config()\nThe second way, which is more general, allows the user to define any Kraus channel to describe effective noise.\nclean_simu.reset_config()\nconfig_dephasing = SimConfig(\n    noise=\"eff_noise\",\n    eff_noise_opers=[qutip.qeye(2), qutip.sigmaz()],\n    eff_noise_probs=[\n        1 - 0.05,\n        0.05,\n    ],  # Need to add up to 1 to be a valid probability distribution\n)\nclean_simu.add_config(config_dephasing)\nclean_simu.show_config()\nThis allows you to design other effective noise channels by inputting the respective Kraus operators.\nLet us now simulate the entire sequence with our two effective noise channels. First, we define some useful functions for our simulations:\ndef noisy_dynamics(clean_simu, config):\n    \"\"\"Gives the result of a noisy simulation.\"\"\"\n    simu = deepcopy(clean_simu)\n    # Adding noise\n    simu.add_config(config)\n    result = simu.run()\n    return result\n\n\ndef plot_basis_population(\n    psi: qutip.Qobj,\n    noise_results: list[SimulationResults],\n    noise_probabilities: list[float],\n    decay_rate: float | None,\n    axis: plt.Axes,\n    convergence_line: float,\n    label: bool = False,\n) -> None:\n    \"\"\"Plots the evolution of the population in state 'psi'.\n\n    Args:\n        psi: The state against which the population is measured.\n        noise_results: A list of QutipEmulator.from_sequenceResults.\n        noise_probabilites: The noise probability associated with\n            each element in 'noise_results'.\n        decay_rate: The decay rate relative to the noise probability.\n            If defined, add the exponential decay curves in the plot.\n        axis: The Axes to plot the curves on.\n        convergence_line: The stationary value for the population of\n            'psi'.\n        label: Whether to add a label or not.\n    \"\"\"\n    noise_pops = []\n    for noise_result in noise_results:\n        population = []\n        for rho_t in noise_result.states:\n            value = psi.dag() * rho_t * psi\n            population.append(np.abs(value[0][0]))\n        noise_pops.append(population)\n\n    times = noise_results[0]._sim_times\n\n    for noise_probability, noise_pop in zip(noise_probabilities, noise_pops):\n        axis.plot(\n            noise_pop,\n            label=rf\"$p$ = {noise_probability}\",\n            color=[0.9 - 0.5 * noise_probability] * 3,\n        )\n    N_realizations = len(noise_probabilities)\n    if decay_rate is not None:\n        for i, noise_prob in enumerate(noise_probabilities):\n            axis.plot(\n                0.5 * (1 + np.exp(-decay_rate * noise_prob * times)),\n                color=\"red\",\n                alpha=0.6,\n                label=\"Damping\" if i == N_realizations - 1 else None,\n            )\n\n    axis.axhline(\n        convergence_line,\n        color=\"black\",\n        linestyle=\"--\",\n        label=\"Final mixed state\",\n    )\n\n    # Put labels outside of the plot\n    if label:\n        axis.legend(\n            bbox_to_anchor=(1.05, 1), loc=\"upper left\", borderaxespad=0.0\n        )\nUsing the above functions we are ready to run our noisy simulations. We will study the effects of dephasing and depolarizing noise for different noise probability realizations.\nclean_simu.reset_config()\n\nnoise_probabilities = np.linspace(0, 1, 5)\ndepolarizing_results = []\ndephasing_results = []\n\nfor noise_probability in noise_probabilities:\n    print(\"Noise probability = \", noise_probability)\n\n    # We configure the dephasing and depolarizing noises\n    config_dephasing = SimConfig(\n        noise=\"dephasing\", dephasing_prob=noise_probability\n    )\n    config_depolarizing = SimConfig(\n        noise=\"depolarizing\", depolarizing_prob=noise_probability\n    )\n\n    # We run the simulations\n    dephasing_result = noisy_dynamics(clean_simu, config_dephasing)\n    depolarizing_result = noisy_dynamics(clean_simu, config_depolarizing)\n\n    # Storage\n    depolarizing_results.append(depolarizing_result)\n    dephasing_results.append(dephasing_result)\n# Basis states definition\nr_state = qutip.basis(2, 0)\ng_state = qutip.basis(2, 1)\nbasis = {\n    \"g\": g_state,\n    \"r\": r_state,\n}\n### Dephasing Channel\n\nIn the following we illustrate the results of the single qubit dephasing channel.\n# We plot the population evolution\nfig, axs = plt.subplots(2)\nfig.suptitle(\"Population evolution with dephasing noise\")\naxs.flat[0].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"Ground state\")\naxs.flat[1].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"Excited state\")\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\nplot_basis_population(\n    basis[\"g\"],\n    dephasing_results,\n    noise_probabilities,\n    0.5,\n    axs[0],\n    1 / 2,\n    True,\n)\nplot_basis_population(\n    basis[\"r\"],\n    dephasing_results,\n    noise_probabilities,\n    0.5,\n    axs[1],\n    1 / 2,\n)\nplt.show()\nThis plot shows the Rabi oscillations over time. You can see the effects of the dephasing channel on the populations of the excited and ground states. When we increase the noise of the dephasing channel, the Rabi oscillations are increasingly damped.\nThe dephasing channel destroys off-diagonal elements of the density matrix, and tends towards a stationary state with zero off-diagonals. The mixed state obtained is the maximally mixed state.\nIn other words the density matrix converges to $\\rho = \\frac{1}{2} \\mathbb I = \\frac{1}{2}(|0\\rangle\\langle 0| + |1\\rangle\\langle 1|)$.\nNotice that the ground state and excited state populations oscillate in phase opposition.\n### Depolarizing Channel\n\nIn the following we illustrate the results of the single qubit depolarizing channel.\nfig, axs = plt.subplots(2)\nfig.suptitle(\"Basis population evolution with the depolarizing noise\")\naxs.flat[0].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"Ground state\")\naxs.flat[1].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"Excited state\")\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\nplot_basis_population(\n    basis[\"g\"],\n    depolarizing_results,\n    noise_probabilities,\n    1.0,\n    axs[0],\n    1 / 2,\n    True,\n)\nplot_basis_population(\n    basis[\"r\"],\n    depolarizing_results,\n    noise_probabilities,\n    1.0,\n    axs[1],\n    1 / 2,\n)\nplt.show()\nAs was the case for the dephasing channel, we observe a damping of the population of both basis states, indicating a convergence torwards the maximally mixed state. However, for matching probability values, the depolarizing channel results in a faster decoherence than the dephasing channel.\nIf we recall the effect of both channels on the Bloch sphere, we see that the depolarizing channel acts uniformly for any state, while the dephasing channel's effect is maximized for Bloch vectors lying on the equator. Therefore, as the Bloch vector oscillates between $\\ket{0}$ and $\\ket{1}$, it still gets progressively smaller. However, its decoherence rate only matches that of the depolarizing channel when crossing the equator, resulting in a compartively longer coherence time.\n## Two-atom noisy simulations\nWe already know what happens in a single qubit configuration, but we would like to study the multi-qubit case. To do so we start with two qubits.\nWe will analyze two configurations. One with nearby atoms and another with distant atoms and see how effective noise channels interact with the system.\nThe concepts of *far* and *nearby* are defined with respect to the Rydberg blockade radius. Two atoms are *nearby* when they are within a blockade radius of one another and *far* otherwise.\n# Rydberg blockade radius\nomega = 2 * np.pi\nr_interatomic = Chadoq2.rydberg_blockade_radius(omega)\nprint(f\"Rydberg radius ({r_interatomic}) > 5 \")\n### Nearby atoms\n# We create two nearby atoms\nreg = Register.from_coordinates([(0, 0), (5, 0)], prefix=\"q\")\n\nreg.draw()\nWe will use the same pulse as before.\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"channel 0\", \"rydberg_global\")\nduration = 10000\npulse = Pulse.ConstantPulse(duration, omega, 0, 0.0)\nseq.add(pulse, \"channel 0\")\nseq.draw()\nclean_simu = QutipEmulator.from_sequence(seq, sampling_rate=0.05)\nclean_res = clean_simu.run()\nTo simulate effective noise channels in multi-qubit systems, we make a first-order approximation and consider only the effect of collapse operators that affect at most one qubit. \n\nThis approximation assumes $p^2 \\ll p$ ($p\\lessapprox 0.2$), so when an effective noise probability is higher than $0.2$, a warning is raised, alerting you are outside the regime of validity for the approximation.\nclean_simu.reset_config()\n\nnoise_probabilities = np.round(np.linspace(0, 0.2, 5), 3)\ndepolarizing_results = []\ndephasing_results = []\n\nfor noise_probability in noise_probabilities:\n    print(\"Noise probability = \", noise_probability)\n\n    # We configure the dephasing and depolarizing noises\n    config_dephasing = SimConfig(\n        noise=\"dephasing\", dephasing_prob=noise_probability\n    )\n    config_depolarizing = SimConfig(\n        noise=\"depolarizing\", depolarizing_prob=noise_probability\n    )\n\n    # We run the simulations\n    dephasing_result = noisy_dynamics(clean_simu, config_dephasing)\n    depolarizing_result = noisy_dynamics(clean_simu, config_depolarizing)\n\n    # Storage\n    depolarizing_results.append(depolarizing_result)\n    dephasing_results.append(dephasing_result)\n# Basis states definition\nr_state = qutip.basis(2, 0)\ng_state = qutip.basis(2, 1)\nbasis = {\n    \"gg\": qutip.tensor(g_state, g_state),\n    \"rg\": qutip.tensor(r_state, g_state),\n    \"gr\": qutip.tensor(g_state, r_state),\n    \"rr\": qutip.tensor(r_state, r_state),\n}\n#### Dephasing Channel\n\nIn the following we illustrate the results of the two-qubit dephasing channel.\nfig, axs = plt.subplots(4)\nfig.suptitle(\"Basis population evolution with dephasing noise\")\naxs.flat[0].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gg> state\")\naxs.flat[1].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rg> state\")\naxs.flat[2].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gr> state\")\naxs.flat[3].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rr> state\")\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\nplot_basis_population(\n    basis[\"gg\"],\n    dephasing_results,\n    noise_probabilities,\n    None,\n    axs[0],\n    1 / 3,\n    True,\n)\nplot_basis_population(\n    basis[\"rg\"], dephasing_results, noise_probabilities, None, axs[1], 1 / 3\n)\nplot_basis_population(\n    basis[\"gr\"], dephasing_results, noise_probabilities, None, axs[2], 1 / 3\n)\nplot_basis_population(\n    basis[\"rr\"], dephasing_results, noise_probabilities, None, axs[3], 1 / 3\n)\nplt.show()\nWe can easily notice that: $\\braket{gg|\\rho(t)|gg}, \\braket{gr|\\rho(t)|gr}$ and $\\braket{rg|\\rho(t)|rg}$ converge to $\\frac{1}{3}$ when $\\braket{rg|\\rho(t)|rg}$ stays at zero.\n\nAtom 2 is inside the Rydberg radius, so the $\\ket{rr}$ state is forbidden.\nThe final mixed state is then: \n\n$$\n\\rho = \\frac{1}{3} (\\ket{gg}\\bra{gg} + \\ket{gr}\\bra{gr} + \\ket{rg}\\bra{rg} )\n$$\nLet's see whether the same happens with the depolarizing channel.\n#### Depolarizing Channel\n\nIn the following we illustrate the results of the two-qubit depolarizing channel.\nfig, axs = plt.subplots(4)\nfig.suptitle(\"Basis population evolution with depolarizing noise\")\naxs.flat[0].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gg> state\")\naxs.flat[1].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rg> state\")\naxs.flat[2].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gr> state\")\naxs.flat[3].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rr> state\")\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\nplot_basis_population(\n    basis[\"gg\"],\n    depolarizing_results,\n    noise_probabilities,\n    None,\n    axs[0],\n    1 / 4,\n    True,\n)\nplot_basis_population(\n    basis[\"rg\"], depolarizing_results, noise_probabilities, None, axs[1], 1 / 4\n)\nplot_basis_population(\n    basis[\"gr\"], depolarizing_results, noise_probabilities, None, axs[2], 1 / 4\n)\nplot_basis_population(\n    basis[\"rr\"], depolarizing_results, noise_probabilities, None, axs[3], 1 / 4\n)\nplt.show()\nAlthough the Rydberg blockade should make the state $\\ket{rr}$ state unreacheble, we observe its population gradually increase over time. This is explained by the fact that the depolarizing noise is making each state vector evolve independently towards the maximally mixed state. Therefore, as coherence is lost, the $\\ket{rr}$ becomes just as likely as any other eigenstate, since both qubits turn into classical mixtures with no correlation between them.   \n\nThus, the final output mixed state is:\n\n$$\n\\rho = \\frac{1}{4} (\\ket{gg}\\bra{gg} + \\ket{gr}\\bra{gr} + \\ket{rg}\\bra{rg} + \\ket{rr}\\bra{rr})\n$$\n### Distant atoms\nreg = Register.from_coordinates([(0, 0), (20, 0)], prefix=\"q\")\n\nprint(f\"20 = R > Rydberg radius = {r_interatomic} \")\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"channel 0\", \"rydberg_global\")\nduration = 10000\npulse = Pulse.ConstantPulse(duration, 2 * np.pi, 0 * np.pi, 0.0)\nseq.add(pulse, \"channel 0\")\n\nclean_simu = QutipEmulator.from_sequence(seq, sampling_rate=0.05)\nclean_res = clean_simu.run()\ndepolarizing_results = []\ndephasing_results = []\n\nfor noise_probability in noise_probabilities:\n    print(\"Noise probability = \", noise_probability)\n\n    # We configure the dephasing and depolarizing noises\n    config_dephasing = SimConfig(\n        noise=\"dephasing\", dephasing_prob=noise_probability\n    )\n    config_depolarizing = SimConfig(\n        noise=\"depolarizing\", depolarizing_prob=noise_probability\n    )\n\n    # We run the simulations\n    dephasing_result = noisy_dynamics(clean_simu, config_dephasing)\n    depolarizing_result = noisy_dynamics(clean_simu, config_depolarizing)\n\n    # Storage\n    depolarizing_results.append(depolarizing_result)\n    dephasing_results.append(dephasing_result)\n#### Dephasing Channel\n\nIn the following we illustrate the results of the two-qubit dephasing channel.\nfig, axs = plt.subplots(4)\nfig.suptitle(\"Basis population evolution with dephasing noise\")\naxs.flat[0].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gg> state\")\naxs.flat[1].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rg> state\")\naxs.flat[2].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gr> state\")\naxs.flat[3].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rr> state\")\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\nplot_basis_population(\n    basis[\"gg\"],\n    dephasing_results,\n    noise_probabilities,\n    None,\n    axs[0],\n    1 / 3,\n    True,\n)\nplot_basis_population(\n    basis[\"rg\"], dephasing_results, noise_probabilities, None, axs[1], 1 / 4\n)\nplot_basis_population(\n    basis[\"gr\"], dephasing_results, noise_probabilities, None, axs[2], 1 / 4\n)\nplot_basis_population(\n    basis[\"rr\"], dephasing_results, noise_probabilities, None, axs[3], 1 / 4\n)\nplt.show()\nWithout the interaction, both qubits now evolve independently towards the maximally mixed state, resulting in\n\n$$\n\\rho = \\frac{1}{4} (\\ket{gg}\\bra{gg} + \\ket{gr}\\bra{gr} + \\ket{rg}\\bra{rg} + \\ket{rr}\\bra{rr})\n$$\n#### Depolarizing Channel\n\nIn the following we illustrate the results of the two-qubit depolarizing channel.\nfig, axs = plt.subplots(4)\nfig.suptitle(\"Basis population evolution with depolarizing noise\")\naxs.flat[0].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gg> state\")\naxs.flat[1].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rg> state\")\naxs.flat[2].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|gr> state\")\naxs.flat[3].set(xlabel=r\"Time ($\\mu s$)\", ylabel=\"|rr> state\")\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\nplot_basis_population(\n    basis[\"gg\"],\n    depolarizing_results,\n    noise_probabilities,\n    None,\n    axs[0],\n    1 / 4,\n    True,\n)\nplot_basis_population(\n    basis[\"rg\"], depolarizing_results, noise_probabilities, None, axs[1], 1 / 4\n)\nplot_basis_population(\n    basis[\"gr\"], depolarizing_results, noise_probabilities, None, axs[2], 1 / 4\n)\nplot_basis_population(\n    basis[\"rr\"], depolarizing_results, noise_probabilities, None, axs[3], 1 / 4\n)\nplt.show()\nAlthough the output state remains the same as before, we observe a different behaviour in the evolution towards it. In fact, without the interaction, we now see that the $\\ket{rr}$ population oscillates freely, which did not occur in the presence of a Rydberg blockade.\n", "params": {}}