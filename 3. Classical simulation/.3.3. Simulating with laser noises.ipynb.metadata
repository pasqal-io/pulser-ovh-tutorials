{"timestamp": 1698744641.550858, "stored_source_code": "# add default values for parameters here\n# Laser noise\n## Introduction\nLaser noises were introduced in the introductory tutorial [Simulating sequences with errors and noises](noisy_sim.nblink). They will be further detailed in this notebook. We recommend you to check the introductory tutorial before going through this one.\n\nThe laser noises model errors coming from the laser-atom interaction itself, encapsulating effects like:\n\n- **Doppler damping**: the atoms in the register are cooled to a temperature $T \\sim 50\\mu K$, which is low but still non-zero. Therefore, the laser frequency they observe doppler-shifted due to thermal motion. This can be seen as a shift in the detuning frequency of the laser.\n- **Waist of the laser**: for global pulses, the laser amplitude has a Gaussian profile and atoms at the border of the waist feel a slightly lower amplitude than those at the focus.\n- **Amplitude fluctuations**: the `amp_sigma` parameter dictates fluctuations in the laser amplitude from pulse to pulse. \n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport qutip\n\nfrom pulser import Register, Pulse, Sequence\nfrom pulser_simulation import SimConfig, QutipEmulator\nfrom pulser.devices import Chadoq2\nfrom pulser.waveforms import RampWaveform\n## Single atom noisy simulations\n### Sequence preparation\nWe start with a single atom away from the center of the register.\nreg = Register.from_coordinates([(0, 30)], prefix=\"q\")\nThen we act on this atom with a Constant Pulse, such that it oscillates between the ground state and excited Rydberg state (Rabi oscillations):\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"channel 0\", \"rydberg_global\")\nduration = 2500\npulse = Pulse.ConstantPulse(duration, 2 * np.pi, 0.0, 0.0)\nseq.add(pulse, \"channel 0\")\nseq.draw()\nThen we create the simulation object with which we will add noises.\nsim = QutipEmulator.from_sequence(seq, sampling_rate=0.05)\nsim.set_evaluation_times(0.4)\nres_clean = sim.run()\nobs = qutip.basis(2, 0).proj()\nconfig_spam = SimConfig(noise=(\"SPAM\"), runs=30, samples_per_run=5)\n### Doppler shift\nAs for any noise, the doppler noise is set via a `SimConfig` object. Note that you can change the standard deviation of the doppler noise, which is $k \\times \\sqrt{k_B T / m}$ where $k$ is the norm of the effective wavevector of the lasers, by changing the temperature field setting it in $\\mu K$.\nWe'll exaggerate the temperature to emphasize the effects of the Doppler shift (the default temperature being $50 \\mu K$).\nconfig_doppler = SimConfig(\n    noise=\"doppler\", runs=100, temperature=5000, samples_per_run=10\n)\nsim.set_config(config_doppler)\nsim.show_config()\nres_clean.plot(obs, label=\"Noiseless\")\nres_doppler = sim.run()\nres_doppler.plot(obs, label=\"With doppler shift\")\nplt.legend(bbox_to_anchor=(1.05, 1), loc=\"upper left\", borderaxespad=0.0)\nplt.ylabel(\"Excited state population\")\nplt.show()\n### Amplitude noise\nWhen activated, we switch to a description of the laser amplitude as a gaussian profile whose standard deviation is the `laser_waist`. \nFurthermore, the amplitude of the laster fluctuates according to a gaussian profile with standard deviation `amp_sigma`.\nsim.reset_config()\nconfig_amp_noise = SimConfig(\n    noise=\"amplitude\",\n    runs=100,\n)\nsim.set_config(config_amp_noise)\nsim.show_config()\nNotice we are now using 100 runs in order to see the effects of the modulations clearly.\nres_clean.plot(obs, label=\"Noiseless\")\nres_doppler = sim.run()\nres_doppler.plot(obs, label=\"With amplitude noise\")\nplt.legend(bbox_to_anchor=(1.01, 1), loc=\"upper left\", borderaxespad=0.0)\nplt.ylabel(\"Excited state population\")\nplt.show()\nEven with the default parameters, we still observe a small damping of the Rabi oscillations.\n## Multiple Atoms\nWe will now run the AFM state preparation sequence from the Pulser tutorial with our noise models and compare the results to the noiseless case.\n\nAt this stage, you know how to manipulate the different laser noises. In this multi-qubit case, we will combine all these effects.\n# Parameters in rad/\u00b5s and ns\nomega_max = 2.3 * 2 * np.pi\ndelta_0 = -6 * 2 * np.pi\ndelta_f = 2 * 2 * np.pi\n\nt_rise = 252\nt_fall = 500\nt_sweep = (delta_f - delta_0) / (2 * np.pi * 10) * 1000\n\nU = 2 * np.pi\nR_interatomic = Chadoq2.rydberg_blockade_radius(U)\n\nn_side = 3\nreg = Register.rectangle(n_side, n_side, R_interatomic * 0.9, prefix=\"q\")\n\nrise = Pulse.ConstantDetuning(\n    RampWaveform(t_rise, 0.0, omega_max), delta_0, 0.0\n)\nsweep = Pulse.ConstantAmplitude(\n    omega_max, RampWaveform(t_sweep, delta_0, delta_f), 0.0\n)\nfall = Pulse.ConstantDetuning(\n    RampWaveform(t_fall, omega_max, 0.0), delta_f, 0.0\n)\n\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"ising\", \"rydberg_global\")\n\nseq.add(rise, \"ising\")\nseq.add(sweep, \"ising\")\nseq.add(fall, \"ising\")\nconfig_all_noise = SimConfig(\n    noise=(\"doppler\", \"amplitude\"),\n    runs=100,\n    samples_per_run=10,\n    amp_sigma=0.1,\n    laser_waist=100,\n    temperature=100,\n)\nsimul = QutipEmulator.from_sequence(\n    seq,\n    sampling_rate=0.05,\n    evaluation_times=0.1,\n    config=config_all_noise,  # Take 10% of the time steps as evaluation times (7 time steps)\n)\nnoisy_results = simul.run()\n\nsimul.reset_config()\nclean_results = simul.run()\nWe will plot the simulation results by sampling the final states. Rather than using the `sample_final_state()` method on the noisy results object (which just samples from the last realization of the noisy simulation), we need to extract the `Counter` object from the `NoisyResults.results` object, which has accumulated the samples of all the simulated runs.\nplt.figure(figsize=(10, 4))\nnoisy_count = noisy_results.results[\n    -1\n]  # Extract the Counter object from the last evaluated time step.\nclean_count = clean_results.sample_final_state(\n    N_samples=100 * 10\n)  # Compare with 100 runs of 10 samples each\n\nclean_most_freq = {k: 100 * v / 1000 for k, v in clean_count.items()}\nnoisy_most_freq = {k: 100 * v for k, v in noisy_count.items()}\n\nplt.bar(\n    clean_most_freq.keys(), list(clean_most_freq.values()), label=\"Noiseless\"\n)\nplt.bar(noisy_most_freq.keys(), list(noisy_most_freq.values()), label=\"Noisy\")\n\n# Only show the xticks to the most frequent states:\nmost_freq = sorted(noisy_count, key=noisy_count.get, reverse=True)[:1]\n\nplt.ylabel(\"Counts (%)\")\nplt.xticks(most_freq, rotation=90)\nplt.title(\"Sampling from the noisy and clean simulations (100x10 samples)\")\nplt.legend(bbox_to_anchor=(1.01, 1), loc=\"upper left\", borderaxespad=0.0)\nplt.show()\nThe bars represent the simulation results as populations of bitstrings. They're colored blue for the noiseless simulation, and orange for the noisy one. We clearly identify the antiferromagnetic state as the most populated one in both cases, but it is slightly less populated in the noisy case, while some other bitstrings, not present in the noiseless case, appear.", "params": {}}