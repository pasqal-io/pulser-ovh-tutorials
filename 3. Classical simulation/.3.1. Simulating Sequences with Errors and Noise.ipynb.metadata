{"timestamp": 1698744573.269491, "stored_source_code": "# add default values for parameters here\n# Simulations with Noise and Errors\n## Introduction\nThis notebook is the first in a series of tutorials on the use of the `pulser-simulation` module to simulate pulse sequences with noise and errors. These are an unavoidable part of a real quantum system, and a good simulation of a pulse sequence should be able to reproduce them accurately. A detailed explanation of these phenomena can be found in the following [reference](https://arxiv.org/abs/1802.10424).\n\nCurrently, `pulser-simulation` supports _noises_ for the laser pulses and _errors_ for the state preparation and measurement stages:\n\n### 1. SPAM (_State Preparation And Measurement_) errors:\n\n- **State Preparation errors**: The initial state preparation can fail to trap all the atoms in the ground state $\\ket{g}$. We model this by the probability $\\eta$ of _not_ having a given atom during processing.\n- **Measurement errors**: In addition, the probabilities $\\epsilon, \\epsilon '$ are linked to detection errors. The first one is the probability of detecting an atom in the ground state $\\ket{g}$ as if it were in the excited state $\\ket{r}$ (\"false positives\"), and the second one is the probability of detecting an atom in the excited state $\\ket{r}$ as if it were in the ground state $\\ket{g}$ (\"false negatives\").\n\n### 2. Laser noises:\nThe fluctuations of the properties of the lasers affect their effectiveness in addressing the desired transitions between atomic levels:\n\n- **Doppler damping**: The atoms in the register are cooled to a temperature $T \\sim 50\\mu K$, which is low but still non-zero. Therefore, the laser frequency they experience is Doppler-shifted due to thermal motion. This can be seen as a shift in the detuning frequency of the laser.\n- **Waist of the laser**: For global pulses, the laser amplitude has a Gaussian profile and atoms at the border of the waist feel a slightly lower amplitude than those at the focus.\n- **Amplitude fluctuations**: Fluctuations in the laser amplitude from pulse to pulse. \n\n### 3. Effective noise channels:\n\nMore generally, we can include effective noise channels in our simulation. These can represent the aggregate of different noise sources, as well as an interaction with an environment. To include these in our simulations, we use the Lindblad master equation, an evolution equation for the _density matrix_ $\\rho$ of the system. Some introductory lecture notes on the topic can be found [here](http://theory.caltech.edu/~preskill/ph219/chap3_15.pdf). `pulser-simulation` includes the following noise channels:\n\n- **Dephasing channel**: Implements a decay in the _coherence_ or _interference_ terms (the off-diagonal terms in $\\rho$). It applies random $z$-rotations on each qubit according to a given probability $p$, the dephasing probability.\n- **Depolarizing channel**: A more general type of noise in which $\\rho$ loses information due to interactions with the environment. This is represented as an evolution towards the completely mixed state $\\rho \\rightarrow \\frac{\\mathbb{I}}{2}$, effectively erasing the coherence in $\\rho$ with a probability $p$.\n- **Custom effective noise channel**: we can also include custom noise channels by providing the Lindblad operators and their coefficients.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport qutip\n\nfrom pulser import Register, Pulse, Sequence\nfrom pulser_simulation import SimConfig, QutipEmulator\nfrom pulser.devices import Chadoq2\n## Single atom noisy simulations\n### Sequence preparation\nWe prepare a single atom.\nreg = Register.from_coordinates([(0, 0)], prefix=\"q\")\nWe act on this atom with a Constant Pulse, such that it oscillates between the ground state and excited Rydberg state (Rabi oscillations):\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"ch0\", \"rydberg_global\")\nduration = 2500\npulse = Pulse.ConstantPulse(duration, 2 * np.pi, 0.0, 0.0)\nseq.add(pulse, \"ch0\")\nseq.draw()\nIn order to characterize simulation results, we designed a dedicated class, the `SimulationResults` class. It has two child classes, the `CoherentResults` for when the final state can be represented as a state vector or density matrix and `NoisyResults` when it can only be provided as a probability distribution of final states.\n\nIn the following, we run a noiseless simulation to obtain a `CoherentResults` object in `clean_res`. This object allows to get useful information on the simulation parameters, the simulation results and more.\nsim = QutipEmulator.from_sequence(seq, sampling_rate=0.05)\nclean_res = sim.run()\nWe can for example plot the expectation values of an observable across time\n# Define Rydberg state observable\nobs = qutip.basis(2, 0).proj()\nplt.figure(figsize=(4, 3))\nplt.plot(clean_res._sim_times, clean_res.expect([obs])[0])\nplt.xlabel(r\"Time ($\\mu s$)\")\nplt.ylabel(r\"Population in $|r\\rangle$\")\nplt.show()\n### The SimConfig object\nEach simulation has an associated `SimConfig` object, which encapsulates parameters such as noise types, the temperature of the register and so on. You can view it at any time using the `show_config()` method:\nsim.show_config()\nWhen creating a new `SimConfig`, you can choose several parameters such as the number of runs and the number of delivered samples per run through the fields `'runs'` and `'samples_per_run'` respectively. The number of samples per run has no physical interpretation, this is used simply to cut down the calculation time by acquiring more shots without resampling the noise parameters.\n### SPAM noise use case\n\nWe will use as a toy example the `SPAM` noise and add it to our simulation in order to describe the different objects used for noisy simulations.\nTo do so, we can create a new `SimConfig` object and assign it to the `config` field of `sim` via the `Simulation.set_config` setter. We pass noise types as a tuple of strings to the `SimConfig` object created.\nYou can list the different types of noises supported for each basis by calling `Simconfig.supported_noises` as follows:\nsim.config.supported_noises\nBy default, all config classes are in the `ising` mode, allowing a wide range of noises. However, for some applications, we need to operate in the `XY` mode, where only the SPAM noise is available for the moment.\nLet's come back to our toy example. We add `\"SPAM\"` noise to our clean simulation, select 30 different realizations of the state taking each time 5 samples per run:\nconfig_spam = SimConfig(noise=(\"SPAM\"), runs=30, samples_per_run=5)\nsim.set_config(config_spam)\nThe configuration is updated, the current parameters of the SPAM errors should be included:\nsim.show_config()\nThe `SimConfig.spam_dict` is the spam parameters dictionary where `eta` is the probability of a badly prepared state, `epsilon` the false positive probability and `epsilon_prime` the false negative one.\nWhen dealing with a `SimConfig` object with different noise parameters from the config in `Simulation.config`, you can \"add\" both configurations together, obtaining a single `SimConfig` with all noises from both configurations - on the other hand, the `runs` and `samples_per_run` will always be updated. This adds simulation parameters to noises that weren't available in the former `Simulation.config`. Noises specified in both `SimConfigs` will keep the noise parameters in `Simulation.config`. Try it out with `Simulation.add_config`:\ncfg2 = SimConfig(\n    noise=(\"SPAM\", \"dephasing\", \"doppler\"),\n    eta=0.8,\n    temperature=1000,\n    runs=50,\n)\nsim.add_config(cfg2)\nsim.show_config()\nWe can observe that the `eta` parameter wasn't changed, since both `SimConfig` objects had `'SPAM'` as a noise model already.\nWe created a noisy simulation using `set_config` and `add_config` methods of the the Simulation class. But it's not the only way, you can directly create a noisy simulation when you create your simulation object.\nsim = QutipEmulator.from_sequence(\n    seq,\n    sampling_rate=0.05,\n    config=SimConfig(\n        noise=(\"SPAM\", \"dephasing\", \"doppler\"),\n        temperature=1000,\n        runs=50,\n    ),\n)\nsim.show_config()\n### Setting evaluation times\nAs a `Simulation` field, `evaluation_times` refers to the times at which you sample during your simulation. You can assign it different types of values:\n\n* A float between 0 and 1: indicating the fraction of the full time array at which you want to sample.\n* The string `'Full'` to evaluate every ns or `'Minimal'` to evaluate only at the start and the end.\n* A time list: if there are specific periods of times at which you want to sample. Only, make sure the list you use is a subset of the hamiltonian sample time list.\nsim.set_evaluation_times(0.5)\nnoisy_res = sim.run()\nWe get a `NoisyResults` object from our noisy simulation. This object represents the final result as a probability distribution over the sampled bitstrings, rather than a quantum state `QObj` in the `CleanResults` case.\n### Plotting noisy and clean results\nThe new `res` instance has similar methods to the usual `SimResults` object. For example, we can calculate expectation values. \nBelow, the comparison between the clean and noise simulations.\nplt.figure(figsize=(4, 3))\nplt.plot(noisy_res._sim_times, noisy_res.expect([obs])[0], label=\"noisy\")\nplt.plot(clean_res._sim_times, clean_res.expect([obs])[0], label=\"clean\")\nplt.xlabel(r\"Time ($\\mu s$)\")\nplt.ylabel(r\"Population in $|r\\rangle$\")\nplt.legend(bbox_to_anchor=(1.05, 1), loc=\"upper left\", borderaxespad=0.0)\nplt.show()\nYou can also use the `SimResults.plot(obs)` method to plot expectation values of a given observable. Here we compute the `sigma_z` local operator expectation values. Error bars are activated by default for noise simulations but if you don't want them you can set to False the field `error_bars`.\nBe wary that computing the expectation value of non-diagonal operators will raise an error, as `NoisyResults` bitstrings are already projected on the $Z$ basis.\nobs = qutip.sigmaz()\nplt.figure(figsize=(4, 3))\nnoisy_res.plot(obs, fmt=\".\")\nNow you have the basic knowledge to tackle noise simulations. In the following tutorials, we will see in more detail simulations with [SPAM errors](spam.nblink), [laser noise](laser_noise.nblink) and [effective noise channels](kraus_ops.nblink). Enjoy!", "params": {}}