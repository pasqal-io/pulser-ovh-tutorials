{"timestamp": 1698744583.330495, "stored_source_code": "# Pulse Sequence Creation\nimport numpy as np\nimport pulser\nfrom pprint import pprint\nfrom pulser import Pulse, Sequence, Register\n## 1. Creating the `Register`\nThe `Register` defines the positions of the atoms and their names of each one. There are multiple ways of defining a `Register`, the most customizable one being to create a dictionary that associates a name (the key) to a cooordinate (the value).\nL = 4\nsquare = np.array([[i, j] for i in range(L) for j in range(L)], dtype=float)\nsquare -= np.mean(square, axis=0)\nsquare *= 5\n\nqubits = dict(enumerate(square))\nreg = Register(qubits)\nThe `Register` class provides some useful features, like the ability to visualise the array and to rotate it.\nreg1 = Register(qubits)  # Copy of 'reg' to keep the original intact\nprint(\"The original array:\")\nreg1.draw()\nreg1.rotate(45)  # Rotate by 45 degrees\nprint(\"The rotated array:\")\nreg1.draw()\nIf one doesn't particularly care about the name given to the qubits, one can also create a `Register` just from a list of coordinates (using the `Register.from_coordinates` class method). In this case, the qubit ID's are just numbered, starting from 0, in the order they are provided in, with the option of adding a common prefix before each number. Also, it automatically centers the entire array around the origin, an option that can be disabled if desired.\nreg2 = Register.from_coordinates(\n    square, prefix=\"q\"\n)  # All qubit IDs will start with 'q'\nreg2.draw()\nFurthermore, there are also built-in class methods from creation of common array patterns, namely:\n- Square lattices in rectangular or square shapes\n- Triangular lattices\n\nWe could, thus, create the same square array as before by doing:\nreg3 = Register.square(4, spacing=5)  # 4x4 array with atoms 5 um apart\nreg3.draw()\n## 2. Initializing the Sequence\nTo create a `Sequence`, one has to provide it with the `Register` instance and the device in which the sequence will be executed. The chosen device will dictate whether the register is valid or not.\n\nWe import the device (in this case, `Chadoq2`) from `pulser.devices` and initialize our sequence with the freshly created register:\nfrom pulser.devices import Chadoq2\n\nseq = Sequence(reg, Chadoq2)\n## 3. Declaring the channels that will be used\nInspecting what channels are available on this device:\nseq.available_channels\nWe're going to choose the `'rydberg_local'` and `'raman_local'` channels. Note how a declared channel is no longer reported as available.\nseq.declare_channel(\"ch0\", \"raman_local\")\nprint(\"Available channels after declaring 'ch0':\")\npprint(seq.available_channels)\n\nseq.declare_channel(\"ch1\", \"rydberg_local\", initial_target=4)\nprint(\"\\nAvailable channels after declaring 'ch1':\")\npprint(seq.available_channels)\nAt any time, we can also consult which channels were declared, their specifications and the name they were given by calling:\nseq.declared_channels\n## 4. Composing the Sequence\nEvery channel needs to start with a target. For `Global` channels this is predefined to be all qubits in the device, but for `Local` channels this has to be defined. This initial target can be set through at channel declaration (see how `'ch1'` was set to target qubit `4`), or it can be done through the standard `target` instruction.\nseq.target(1, \"ch0\")\nNow both channels have an initial target, so we can start building the sequence. Let's start by creating a simple pulse with a constant Rabi frequency of 2 rad/\u00b5s and a constant detuning of -10 rad/\u00b5s that lasts 200 ns.\nsimple_pulse = Pulse.ConstantPulse(200, 2, -10, 0)\nLet's add this pulse to `'ch0'`:\nseq.add(simple_pulse, \"ch0\")\nNow, say we want to idle `'ch1'` for 100 ns while `'ch0'` is doing its pulse. We do that by calling: \nseq.delay(100, \"ch1\")\nNext, we want to create a more complex pulse to add to `'ch1'`, where the amplitude and the detuning are not constant. To do that, we use `Waveform`s:\nfrom pulser.waveforms import RampWaveform, BlackmanWaveform\n\nduration = 1000\namp_wf = BlackmanWaveform(duration, np.pi / 2)  # Duration: 1000 ns, Area: pi/2\ndetuning_wf = RampWaveform(\n    duration, -20, 20\n)  # Duration: 1000ns, linear sweep from -20 to 20 rad/\u00b5s\nWe can visualize a waveform by calling:\namp_wf.draw()\nAlso, it is often convenient to find the integral of a waveform, which can be obtain by calling:\namp_wf.integral  # dimensionless\nWe then create the pulse with the waveforms instead of fixed values and we can also visualize it:\ncomplex_pulse = Pulse(amp_wf, detuning_wf, phase=0)\ncomplex_pulse.draw()\nWhen we're satisfied, we can then add it to a channel:\nseq.add(complex_pulse, \"ch1\")\nLet's check the schedule to see how this is looking:\nprint(seq)\nWe can also draw the sequence, for a more visual representation:\nseq.draw()\nNow, let's see how the Sequence builder handles conflicts (i.e. two channels acting on the same qubit at once). We're going to add a `complex_pulse`to `'ch0'`, but now we want to target it to qubit `4`, which is the same target of `'ch1'`.\nseq.target(4, \"ch0\")\nseq.add(complex_pulse, \"ch0\")\n\nprint(\"Current Schedule:\")\nprint(seq)\nseq.draw()\nBy looking at the current schedule, we can see that `'ch0'` was delayed from `ti=220` to `tf=1100`, and only then was the `complex_pulse` added. The reason for this is simple: it had to wait for the pulse on `ch1`, also targeted to qubit `4`, to finish before it could apply its own. It behaved this way because, in `Sequence.add` there is a default argument `protocol='min-delay`.\nAnother protocol for pulse addition is `wait-for-all`, which makes the new pulse wait even if there is no conflict. Let's remove the conflict and add two `simple_pulse`s to `ch1` with the different protocols to see how the compare.\nseq.target(0, \"ch1\")\nseq.add(simple_pulse, \"ch1\", protocol=\"min-delay\")\nseq.add(simple_pulse, \"ch1\", protocol=\"wait-for-all\")\n\nprint(\"Current Schedule:\")\nprint(seq)\nseq.draw()\nBecause we removed the conflict by changing the target of `ch1` to qubit `0`, we see that the first pulse was added without delay from `ti=1100` to `tf=1300` (i.e. while `complex_pulse` is still running in `ch0`). However, once we changed to `protocol='wait-for-all'`, there is now a delay (from `ti=1300` to `tf=2100`) that idles `ch1` until `ch0`is finished with its pulse, even though there was no conflict.\nThe third protocol is called `'no-delay'` which, as the name implies, never delays the channel where the pulse is being added, even if that means introducing a conflict.\nseq.target(0, \"ch0\")\nseq.add(complex_pulse, \"ch0\", protocol=\"no-delay\")\n\nprint(\"Current Schedule:\")\nprint(seq)\nseq.draw()\nWith this protocol, it is possible (though not advised), to create an overlap where multiple channels can be acting on the same qubit at the same time. Here, we can see that both act on qubit `0` from `ti=2100` to `tf=2300`.\n## 5. Measurement\nTo finish a sequence, we measure it. A measurement signals the end of a sequence, so after it no more changes are possible. We can measure a sequence by calling:\nseq.measure(basis=\"ground-rydberg\")\nWhen measuring, one has to select the desired measurement basis. The availabe options depend on the device and can be consulted by calling:\nChadoq2.supported_bases\nAnd so, we've obtained the final sequence!\nseq.draw()\n", "params": {}}