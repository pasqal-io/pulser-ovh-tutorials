{"timestamp": 1698744644.715209, "stored_source_code": "# Simulation of Sequences\nfrom pulser import Pulse, Sequence, Register\nfrom pulser_simulation import QutipEmulator\nfrom pulser.waveforms import BlackmanWaveform, RampWaveform\nfrom pulser.devices import MockDevice\n\nimport numpy as np\nimport qutip\nimport matplotlib.pyplot as plt\nTo illustrate the simulation of sequences, let us study a simple one-dimensional system with periodic boundary conditions (a ring of atoms):\n# Setup\nL = 14\n\nOmega_max = 2.3 * 2 * np.pi\nU = Omega_max / 2.3\n\ndelta_0 = -3 * U\ndelta_f = 1 * U\n\nt_rise = 2000\nt_fall = 2000\nt_sweep = (delta_f - delta_0) / (2 * np.pi * 10) * 5000\n\n# Define a ring of atoms distanced by a blockade radius distance:\nR_interatomic = MockDevice.rydberg_blockade_radius(U)\ncoords = (\n    R_interatomic\n    / (2 * np.tan(np.pi / L))\n    * np.array(\n        [\n            (np.cos(theta * 2 * np.pi / L), np.sin(theta * 2 * np.pi / L))\n            for theta in range(L)\n        ]\n    )\n)\n\nreg = Register.from_coordinates(coords, prefix=\"atom\")\n\nreg.draw(blockade_radius=R_interatomic, draw_half_radius=True, draw_graph=True)\nWe use the drawing capabilites of the `Register` class to highlight the area **half** the blockade radius away from each atom, which makes it so that overlapping circles correspond to interacting atoms. This is further fleshed out by the graph edges drawn using the `draw_graph` option.\nIn this register, we shall act with the following pulser sequence, which is designed to reach a state with *antiferromagnetic order*:\nrise = Pulse.ConstantDetuning(\n    RampWaveform(t_rise, 0.0, Omega_max), delta_0, 0.0\n)\nsweep = Pulse.ConstantAmplitude(\n    Omega_max, RampWaveform(t_sweep, delta_0, delta_f), 0.0\n)\nfall = Pulse.ConstantDetuning(\n    RampWaveform(t_fall, Omega_max, 0.0), delta_f, 0.0\n)\n\nseq = Sequence(reg, MockDevice)\nseq.declare_channel(\"ising\", \"rydberg_global\")\n\nseq.add(rise, \"ising\")\nseq.add(sweep, \"ising\")\nseq.add(fall, \"ising\")\n\nseq.draw()\n## 1. Running a Simulation\nFirst we define our `QutipEmulator` object, which creates an internal respresentation of the quantum system, including the Hamiltonian which will drive the evolution:\nsim = QutipEmulator.from_sequence(seq, sampling_rate=0.1)\nNotice we have included the parameter `sampling_rate` which allows us to determine how many samples from the pulse sequence we wish to simulate. In the case of the simple shapes in our sequence, only a very small fraction is needed. This largely accelerates the simulation time in the solver.\nTo run the simulation we simply apply the method `run()`. At the time of writing of this notebook, the method uses a series of routines from **QuTiP** for solving the Schr\u00f6edinger equation of the system. It returns a `SimulationResults` object, which will allow the study or post-processing of the states for each time step in our simulation. Additionally, we can include a progress bar to have an estimate of how the simulation is advancing:\nresults = sim.run(progress_bar=True)\n## 2. Using the `SimulationResults` object\nThe `SimulationResults` object that we created contains the quantum state at each time step. We can call them using the `states` attribute:\nresults.states[23]  # Given as a `qutip.Qobj` object\nWe can sample the final state directly, using the `sample_final_state()` method from the `SimulationResults` object. We try it with $1000$ samples and discard the less frequent bitstrings:\ncounts = results.sample_final_state(N_samples=1000)\n\nlarge_counts = {k: v for k, v in counts.items() if v > 5}\n\nplt.figure(figsize=(15, 4))\nplt.xticks(rotation=90, fontsize=14)\nplt.title(\"Most frequent observations\")\nplt.bar(large_counts.keys(), large_counts.values())\nNotice how the most frequent bitstrings correspond to the antiferromagnetic order states.\nWe can also compute the expectation values of operators for the states in the evolution, using the `expect()` method, which takes a list of operators (in this case, the local magnetization acting on the $j$-th spin):\ndef magnetization(j, total_sites):\n    prod = [qutip.qeye(2) for _ in range(total_sites)]\n    prod[j] = qutip.sigmaz()\n    return qutip.tensor(prod)\n\n\nmagn_list = [magnetization(j, L) for j in range(L)]\nexpect_magnetization = results.expect(magn_list)\nfor data in expect_magnetization:\n    plt.plot(sim.evaluation_times, data)\nNotice how the local magnetization on *each* atom goes in the same way from $-1$ (which corresponds to the ground state) to $0$. This is expected since as we saw above, the state after the evolution has antiferromagnetic-order, so at each site, there is a compensation of magnetization. The parity (even) and the boundary conditions (periodic) allow for two lowest-energy states, whose superposition is similar to that of the perfectly antiferromagnetic state:  $\\Big(|grgr\\cdots \\rangle + |rgrg\\cdots \\rangle\\Big)/\\sqrt{2}$", "params": {}}