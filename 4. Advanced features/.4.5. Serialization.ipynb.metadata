{"timestamp": 1698744543.640791, "stored_source_code": "# add default values for parameters here\n# JSON Serialization\nimport numpy as np\nfrom pulser import Pulse, Sequence, Register\nfrom pulser.waveforms import BlackmanWaveform\nfrom pulser.devices import Chadoq2\nOften times, it is useful to import/export a given `Sequence` between different locations. To enable this, the `Sequence` object supports **serialization** and **deserialization** into JSON-formatted strings. This will work for any given `Sequence`. Take for example, this sequence that creates the Bell state $|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}$:\nqubits = {\"control\": (-2, 0), \"target\": (2, 0)}\nreg = Register(qubits)\n\nseq = Sequence(reg, Chadoq2)\npulse_time = seq.declare_variable(\"pulse_time\", dtype=int)\nseq.declare_channel(\"digital\", \"raman_local\", initial_target=\"control\")\nseq.declare_channel(\"rydberg\", \"rydberg_local\", initial_target=\"control\")\n\nhalf_pi_wf = BlackmanWaveform(pulse_time, area=np.pi / 2)\n\nry = Pulse.ConstantDetuning(amplitude=half_pi_wf, detuning=0, phase=-np.pi / 2)\nry_dag = Pulse.ConstantDetuning(\n    amplitude=half_pi_wf, detuning=0, phase=np.pi / 2\n)\n\nseq.add(ry, \"digital\")\nseq.target(\"target\", \"digital\")\nseq.add(ry_dag, \"digital\")\n\npi_wf = BlackmanWaveform(pulse_time, np.pi)\npi_pulse = Pulse.ConstantDetuning(pi_wf, 0, 0)\n\nmax_val = Chadoq2.rabi_from_blockade(9)\ntwo_pi_wf = BlackmanWaveform.from_max_val(max_val, 2 * np.pi)\ntwo_pi_pulse = Pulse.ConstantDetuning(two_pi_wf, 0, 0)\n\nseq.align(\"digital\", \"rydberg\")\nseq.add(pi_pulse, \"rydberg\")\nseq.target(\"target\", \"rydberg\")\nseq.add(two_pi_pulse, \"rydberg\")\nseq.target(\"control\", \"rydberg\")\nseq.add(pi_pulse, \"rydberg\")\n\nseq.align(\"digital\", \"rydberg\")\nseq.add(ry, \"digital\")\nseq.measure(\"digital\")\nseq1 = seq.build(pulse_time=200)\nseq1.draw()\n## Serialize\nTo serialize, use `Sequence.to_abstract_repr()`:\ns_readable = seq.to_abstract_repr(\n    json_dumps_options={\"indent\": 1},\n    seq_name=\"Sequence_with_defaults\",\n)\nprint(s_readable[:350], \"...\")\nWe can note that it is possible to provide optional parameters of `json.dumps` such as `indent` via a dictionnary in the argument `json_dumps_options`.\n\nProviding optional arguments to `to_abstract_repr` defines default parameters in the JSON object (like the name of the sequence `seq_name`). This does not change the `Sequence` object in itself, as we'll see in the following part about deserialization.\n## Deserialize\nThe generated strings contain all the necessary information for recreating the original sequence elsewhere (it could, for example, be saved to a file and then imported). To recover the sequence `seq` from `s_readable` (converted into JSON using `Sequence.to_abstract_repr()`), one should use `Sequence.from_abstract_repr()`. \nrecovered_seq = Sequence.from_abstract_repr(s_readable)\nrecovered_seq.build(pulse_time=200).draw()", "params": {}}