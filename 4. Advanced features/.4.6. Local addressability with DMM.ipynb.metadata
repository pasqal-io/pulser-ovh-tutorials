{"timestamp": 1698744556.840539, "stored_source_code": "# add default values for parameters here\n# Local Adressability with DMM\nfrom dataclasses import replace\nfrom matplotlib import pyplot as plt\nfrom pulser.channels.dmm import DMM\nfrom pulser.devices import AnalogDevice\nfrom pulser.register import Register\nfrom pulser.register.register_layout import RegisterLayout\nfrom pulser.register.mappable_reg import MappableRegister\nfrom pulser.register.weight_maps import DetuningMap\nfrom pulser.sampler import sampler\nfrom pulser.sequence import Sequence\nfrom pulser.pulse import Pulse\nfrom pulser.waveforms import ConstantWaveform, RampWaveform\n## Introduction\nEven when working with **global** addressing channels, the **detuning** of individual qubits can be addressed **locally** by using a specific channel named the **Detuning Map Modulator** or `DMM`.\n\nThis `Channel` applies a `Global` pulse of **zero amplitude** and **negative detuning** on a `DetuningMap`. The `DetuningMap` consists of a set of weights on specific sites that dictate how the detuning applied by the `DMM` is distributed.\n\nThis modulation of the `DetuningMap` by the `DMM` Channel is equivalent to adding a term $-\\frac{\\hbar}{2}\\sum_{i}\\epsilon_{i}\\Delta(t)\\sigma^{z}_{i}$ to the Ising Hamiltonian. Here, $\\Delta(t)$ is the detuning applied on the `DMM`, and $(\\epsilon_i)_{i}$ are the weights defined in the `DetuningMap` for each atom.\n## Define a Detuning Map\nA `DetuningMap` associates a set of locations with a set of weights. The weights $(\\epsilon_i)_i$ have to be positive, between 0 and 1, and their sum has to be equal to 1. The locations are the trap coordinates to address.\ntrap_coordinates = [(0.0, 0.0), (0.0, 5.0), (5.0, 0.0), (5.0, 5.0)]\nweights_1 = [0.5, 0.25, 0.25, 0]  # between 0 and 1, sum equal to 1\nweights_2 = [1 / 3, 1 / 3, 1 / 3, 0]  # between 0 and 1, sum equal to 1\nThe `DetuningMap` can be defined from a `RegisterLayout`, a `Register` or a `MappableRegister` by using the `define_detuning_map` method. All it takes is a mapping between trap/qubit IDs and weights.\nregister_layout = RegisterLayout(trap_coordinates)\ndetuning_map = register_layout.define_detuning_map(\n    {i: weights_1[i] for i in range(4)}  # mapping between trap ids and weights\n)\n\nmap_reg = MappableRegister(register_layout)\ndet_map_from_map_reg = map_reg.define_detuning_map(\n    {i: weights_1[i] for i in range(4)}  # mapping between trap ids and weights\n)\n\nregister = Register.from_coordinates(\n    trap_coordinates, center=False, prefix=\"q\"\n)\ndet_map_from_reg = register.define_detuning_map(\n    {\n        f\"q{i}\": weights_1[i] for i in range(4)\n    }  # mapping between qubit ids and weights\n)\n\ndetuning_map.draw(labels=[0, 1, 2, 3])\nassert detuning_map == det_map_from_map_reg\nassert detuning_map == det_map_from_reg\nThe traps are represented by a grey dot and highlighted by a grey square, whose shade is proportional to the value of the associated weight. It is possible to display the value of the weights by specifying a list of `labels`. If the weight is null then no `DMM` is applied: the atom is not highlighted by a grey square and the value of the weight is not shown when `labels` are specified.\ndetuning_map_2 = register_layout.define_detuning_map(\n    {i: weights_2[i] for i in range(4)}  # mapping between trap ids and weights\n)\ndetuning_map_2.draw(labels=[0, 1, 2, 3])\n## DMM Channel and Device\nA `DMM` Channel is a `Channel` that accepts pulses of zero amplitude and detuning below 0 and above `bottom_detuning`:\ndmm = DMM(\n    clock_period=4,\n    min_duration=16,\n    max_duration=2**26,\n    mod_bandwidth=8,\n    bottom_detuning=-20,  # detuning between 0 and -20 rad/\u00b5s\n)\nThe `DMM` channels are defined separately from the other channels of the device. They are defined as a list in `dmm_objects`. They can be accessed via the property `dmm_channels` of the device, where an id is automatically associated to each `DMM` with the format `dmm_{index of appearance in dmm_objects}`.\nmock_device = replace(\n    AnalogDevice.to_virtual(),\n    dmm_objects=(dmm, DMM()),\n    reusable_channels=True,\n)\nprint(mock_device.dmm_channels)\n## DMM in a Sequence\nIn a `Sequence` defined with a `Device` having `dmm_objects`, the `DMM` channels can be configured using `config_detuning_map`. This configuration associates a `DMM` - referenced by `dmm_id` in the `Device`- with a `DetuningMap`, under a `dmm_name` in the `Sequence`.\nseq = Sequence(register, mock_device)\nseq.config_detuning_map(detuning_map, \"dmm_0\")\nprint(seq.declared_channels)\nThe `dmm_name` is generated automatically. It is `dmm_id` if no detuning map has been associated to the `DMM` referenced by `dmm_id` in the device, otherwise it takes the suffix `_{number of times dmm_id has been declared so far}`. For instance, if we associate a new detuning map to `dmm_0` in the previous sequence, the name of this new declared channel will be `dmm_0_1`. To be noted that configuring a `dmm_id` multiple times is only possible in a `VirtualDevice` with `reusable_channels=True`.\nseq.config_detuning_map(detuning_map_2, \"dmm_0\")\nprint(seq.declared_channels.keys())\nLet's now apply a global detuning on the detuning maps. This is done by calling `add_dmm_detuning` and providing a waveform (the detuning $\\Delta(t)$ to modulate the `DetuningMap` with) and the `dmm_name` to use (provides the `DetuningMap` and checks that $\\Delta(t)$ is in agreement with the characteristics of the corresponding `DMM`).\nseq.add_dmm_detuning(ConstantWaveform(100, -10), \"dmm_0\")\nseq.add_dmm_detuning(ConstantWaveform(100, -10), \"dmm_0_1\")\nseq.draw(draw_detuning_maps=True)\nOnce a detuning map is configured, it is not possible to define a `Microwave` channel. However, it is possible to declare `Rydberg` and `Raman` channels. Let's declare a `Rydberg.Global` channel in our sequence.\nseq.declare_channel(\"ryd_glob\", \"rydberg_global\")\nBe careful with the protocols that are used to add the pulses to `Channels` and `DMM`:\n    \n   - The protocol to add a waveform to a `DMM` is by default `\"no-delay\"`, meaning that it will be added straight after the last pulse, without caring about the other channels. This is why the pulse on `dmm_0_1` is added at $t=0$. It can be changed to other values by defining the `protocol` argument.\n   - The protocol to add a pulse to a `Rydberg` or a `Raman` channel is `\"min-delay\"`, meaning that the pulse will by default be added after the end of the pulse of a `DMM`. It can be switched to `\"no-delay\"`.\n\nseq.add(\n    Pulse.ConstantPulse(100, 10, 4.5, 0), \"ryd_glob\", protocol=\"no-delay\"\n)  # added at the beginning with protocol \"no delay\"\nseq.add_dmm_detuning(RampWaveform(200, -10, 0), \"dmm_0\")  # added at t=100\nseq.add(\n    Pulse.ConstantPulse(100, 5, 0, 0), \"ryd_glob\", protocol=\"no-delay\"\n)  # added at t=100\nseq.draw()\nIt is possible to display the amplitude and detuning per qubits, by setting to `True` the arguments `draw_qubit_amp` and `draw_qubit_det`. This adds two plots after the drawing of the sequence. The first one shows the evolution of these quantities along time for groups of qubits experiencing the same amplitude or detuning. The second represents these group of qubits on a register. \nseq.draw(\n    mode=\"input+output\",  # \"input\" only shows input signals, \"input+output\"\n    draw_qubit_det=True,\n    draw_qubit_amp=True,\n)\nYou can see that by combining a global pulse with a positive detuning and pulses on the `DMM` channels, it is possible to have **positive local detuning** (see the detuning on `q3` from `t=0` to `t=100ns`).\n\nIt can also be noted that from `t=100ns` to `t=300ns`, the local detuning is defined by the detuning ramp applied on `detuning_map`, hence it is locally a detuning ramp, going to 0 with a slope defined by the weight of `detuning_map` on each atom. This is why the detuning on `q3` during this duration is constant equal to 0 and that `q1` and `q2` have the same local detuning.", "params": {}}