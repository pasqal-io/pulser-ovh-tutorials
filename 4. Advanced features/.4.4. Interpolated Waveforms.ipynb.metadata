{"timestamp": 1698744545.644141, "stored_source_code": "# add default values for parameters here\n# Interpolated Waveforms\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport pulser\nfrom pulser import Pulse, Sequence, Register\nfrom pulser.devices import Chadoq2\nfrom pulser.waveforms import InterpolatedWaveform\nIn some particular applications (the most notorious being its use in optimal control at the pulse level) it is useful to define a waveform through the interpolation of a set of data points. For these cases, Pulser provides the `InterpolatedWaveform` class.\nIn its most stripped back form, the `InterpolatedWavefrom` requires two things: a `duration` and a list of `values`. The placement of these values along the times axis defaults to spacing the values evenly along the whole duration of the waveform. \n# A standard interpolation (using PchipInterpolator)\nduration = 1000\nvalues = [0, 1, 4.4, 2, 3, 1, 0]\nint_wf = InterpolatedWaveform(duration, values)\nint_wf.draw()\nIf we want to specify the time coordinate of each data point, we can do so through the `times` option. These should come in a list of values betwen `0` and `1`, which are interperted as fractions of the total duration. As an example, below we specify that the `values` are all bunched in the first half of the waveform, except for the last one, which is left at the end.\nts = np.r_[np.linspace(0.0, 0.5, num=len(values) - 1), 1]\nint_wf_t = InterpolatedWaveform(duration, values, times=ts)\nint_wf_t.draw()\nThe other crucial component is the `interpolator`. Currently, the class supports two interpolator classes from the `scipy.interpolate` module: `PchipInterpolator` (chosen by default) and `interp1d`. Below, we change the interpolator to `interp1d`, which does a linear interpolation by default:\nint_wf2 = InterpolatedWaveform(duration, values, interpolator=\"interp1d\")\nint_wf2.draw()\nOne can also change the optional parameters of the chosen interpolator by giving them to `InterpolatedWaveform`. For example, the interpolation with `interp1d` can be cubic instead of linear by changing the `kind` parameter.\n\nNaturally, the choice of interpolator will dictate which extra parameters can be optionally provided. As such, one must refer to the chosen interpolator's documentation for the specific details.\nint_wf3 = InterpolatedWaveform(\n    duration, values, interpolator=\"interp1d\", kind=\"cubic\"\n)\nint_wf3.draw()\nFinally, an `InterpolatedWaveform` can be streched or contracted in both magnitude and duration: \n# Streching an interpolated waveform\nint_wf_stretch_y = int_wf * 2\nint_wf_stretch_x = int_wf.change_duration(duration * 2)\n\nfig, ax = plt.subplots()\nax.plot(int_wf.samples, label=\"Original\")\nax.plot(int_wf_stretch_y.samples, label=\"Streched in Y\")\nax.plot(int_wf_stretch_x.samples, label=\"Streched in X\")\nax.legend()\nplt.show()\n### Use in a parameterized sequence\nThe `InterpolatedWaveform` is used like any other waveform. In the contexts where it usually comes up, it might be helpful to incorporate it in a parametrized sequence. Below, we'll show how to make a parametrized sequence where the data points for the amplitude and detuning waveforms are variables.\nreg = Register.square(2)\nparam_seq = Sequence(reg, Chadoq2)\nparam_seq.declare_channel(\"rydberg_global\", \"rydberg_global\", initial_target=0)\namp_vals = param_seq.declare_variable(\"amp_vals\", size=5, dtype=float)\ndet_vals = param_seq.declare_variable(\"det_vals\", size=4, dtype=float)\n\namp_wf = InterpolatedWaveform(1000, amp_vals)\ndet_wf = InterpolatedWaveform(\n    1000, det_vals, interpolator=\"interp1d\", kind=\"cubic\"\n)\npls = Pulse(amp_wf, det_wf, 0)\n\nparam_seq.add(pls, \"rydberg_global\")\nFrom here, we can build some random sequence by specifying the values of `amp_vals` and `det_vals`. For example:\nseq1 = param_seq.build(amp_vals=[0, 2, 1, 2, 0], det_vals=[0, -5, 5, -5])\nseq1.draw()\nNotice how the interpolation points are automatically drawn on top of the waveforms. You can disable this option through the `draw_interp_pts` parameter:\nseq1.draw(draw_interp_pts=False)", "params": {}}