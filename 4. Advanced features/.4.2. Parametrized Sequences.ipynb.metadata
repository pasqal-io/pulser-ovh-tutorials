{"timestamp": 1698744549.01346, "stored_source_code": "# add default values for parameters here\n# Parametrized Sequences\nimport numpy as np\nimport pulser\nfrom pulser import Pulse, Sequence, Register\nfrom pulser.waveforms import RampWaveform, BlackmanWaveform, CompositeWaveform\nfrom pulser.devices import Chadoq2\nFrom simple sweeps to variational quantum algorithms, it is often the case that one wants to try out multiple pulse sequences that vary only in a few parameters. For this effect, the ability to make a `Sequence` **parametrized** was developed.\n\nA parametrized `Sequence` can be used just like a \"regular\" `Sequence`, with a few key differences. Initialization and channel declaration, for example, don't change at all: \nreg = Register.square(2, prefix=\"q\")\nseq = Sequence(reg, Chadoq2)\nseq.declare_channel(\"rydberg\", \"rydberg_global\")\nseq.declare_channel(\"raman\", \"raman_local\")\n## Variables and Parametrized Objects\nThe defining characteristic of a parametrized `Sequence` is its use of **variables**. These variables are declared within a `Sequence`, by calling:\nOmega_max = seq.declare_variable(\"Omega_max\")\nts = seq.declare_variable(\"ts\", size=2, dtype=int)\nlast_target = seq.declare_variable(\"last_target\", dtype=int)\nThe returned `Omega_max`, `ts` and `last_target` objects are of type `Variable`, and are defined by their name, size and data type. In this case, `Omega_max` is a single variable with `dtype=float` (the default), `ts` is an array of two `int` values and `last_target` is an `int`.\n\nThese returned `Variable` objects support simple arithmetic operations (when applicable) and, when of `size > 1`, even item indexing. Take the following examples:\nt_rise, t_fall = ts  # Unpacking is possible too\nU = Omega_max / 2.3\ndelta_0 = -6 * U\ndelta_f = 2 * U\nt_sweep = (delta_f - delta_0) / (2 * np.pi * 10) * 1000\nBoth the original `Variables` and the results of these operations serve as valid inputs for `Waveforms`, `Pulses` or `Sequence`-building instructions. We can take `Omega_max` as an argument for a waveform:\npi_wf = BlackmanWaveform.from_max_val(Omega_max, np.pi)\nor use derived quantities, like `t_rise`, `t_fall`, `delta_0` and `delta_f`:\nrise_wf = RampWaveform(t_rise, delta_0, delta_f)\nfall_wf = RampWaveform(t_fall, delta_f, delta_0)\nrise_fall_wf = CompositeWaveform(rise_wf, fall_wf)\nThese waveforms are *parametrized* objects, so usual attributes like `duration` or `samples` are not available, as they depend on the values of the underlying variables. Nonetheless, they can be used as regular waveforms when creating `Pulses`, which will consequently be *parametrized* too.\npi_pulse = Pulse.ConstantDetuning(pi_wf, 0, 0)\nrise_fall = Pulse.ConstantAmplitude(Omega_max, rise_fall_wf, 0)\n## Constructing the Sequence\nUpon initialization, a `Sequence` is, by default, not parametrized. We can check this by calling:\nseq.is_parametrized()\nWhile it is not parametrized, it is just a normal sequence. We can do the usual stuff, like targeting a local channel, adding regular pulses, or plotting the sequence:\ngeneric_pulse = Pulse.ConstantPulse(100, 2 * np.pi, 2, 0.0)\nseq.add(generic_pulse, \"rydberg\")\nseq.target(\"q0\", \"raman\")\nseq.add(generic_pulse, \"raman\")\nseq.draw()\nThe `Sequence` becomes parametrized at the moment a parametrized object or variable is given to a sequence-building instruction. For example:\nseq.target_index(last_target, \"raman\")\nseq.is_parametrized()\nFrom this point onward, functionalities like drawing are no longer available, because the instructions start being stored instead of executed on the fly. We can still check the current state of a parametrized sequence by printing it:\nprint(seq)\nNaturally, we can also add the parametrized pulses we previously created:\nseq.add(rise_fall, \"rydberg\")\nseq.add(pi_pulse, \"raman\")\n## Building\nOnce we're happy with our parametrized sequence, the last step is to build it into a regular sequence. For that, we call the `Sequence.build()` method, in which we **must attribute values for all the declared variables**:\nbuilt_seq = seq.build(\n    Omega_max=2.3 * 2 * np.pi,\n    ts=[200, 500],\n    last_target=reg.find_indices([\"q3\"])[0],\n)\nbuilt_seq.draw()\nAnd here we have a regular sequence, built from our parametrized sequence. To create a new one with different parameters, we can simply build it again with new values:\nalt_seq = seq.build(\n    Omega_max=2 * np.pi, ts=[400, 100], last_target=reg.find_indices([\"q2\"])[0]\n)\nalt_seq.draw()", "params": {}}