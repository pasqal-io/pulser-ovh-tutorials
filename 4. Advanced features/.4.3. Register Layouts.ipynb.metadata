{"timestamp": 1698744553.112263, "stored_source_code": "# add default values for parameters here\n# Register Layouts & Mappable Registers\nimport numpy as np\n\nfrom pulser.register.register_layout import RegisterLayout\nfrom pulser import Sequence, Pulse\nOne of the strengths of neutral-atom QPUs is their ability to arrange the atoms in arbitrary configurations. Experimentally, this is realized by creating a layout of optical traps where individual atoms can be placed to create the desired Register. \n\nGiven an arbitrary register, a neutral-atom QPU will generate an associated layout that will then have to be calibrated. Each new calibration takes some time, so it is often prefered to reuse an existing layout that has already been calibrated, whenever possible.\n\nTherefore, it can be of interest to the QPU provider to specify which layouts are already calibrated in their QPU, such that the user can reuse them to specify their `Register`. In Pulser, these layouts are provided as instances of the `RegisterLayout` class.\n## Arbitrary Layouts\nA `RegisterLayout` layout is defined by a set of trap coordinates. These coordinates are systematically ordered in the same way, making two layouts with the same set of trap coordinates identical. \n\nBelow, we create an arbitrary layout of 20 traps randomly placed in a 2D plane. Optionally, a layout may also have an associated `slug` to help identifying it.\n# Generating random coordinates\nnp.random.seed(301122)  # Keeps results consistent between runs\ntraps = np.random.randint(0, 30, size=(20, 2))\ntraps = traps - np.mean(traps, axis=0)\n\n# Creating the layout\nlayout = RegisterLayout(traps, slug=\"random_20\")\nGiven a `RegisterLayout` instance, the best way to inspect it is through `RegisterLayout.draw()`. Notice the default ordering of the atoms (ascending order in x, if tied then in y, if tied then in z):\nlayout.draw()\n### Useful properties\nTo access the trap coordinates:\n- `RegisterLayout.traps_dict` gives a mapping between trap IDs and coordinates\n- `RegisterLayout.coords` provides the ordered list of trap coordinates\nTo identify a layout, one can use its `repr()` for a unique identifier or its `str()` for the `slug` (if specified).\nprint(\"The layout slug:\", layout)\nprint(\"The unique ID layout:\", repr(layout))\n### Register definition\nMore often than not, a `RegisterLayout` will be created by the hardware provider and given to the user. From there, the user must define the desired `Register` to initialize the `Sequence`. This can be done in multiple ways: \n**1. Defined by the trap IDs:**\nYou can find the ID of each trap from its drawing or from the `RegisterLayout.traps_dict`. With those, you can define your register (optionally providing a list of qubit IDs):\ntrap_ids = [4, 8, 19, 0]\nreg1 = layout.define_register(*trap_ids, qubit_ids=[\"a\", \"b\", \"c\", \"d\"])\nreg1.draw()\nNote that the information of the layout is stored internally in the Register:\nreg1.layout\n**2. Defined from the trap coordinates:**\nAlternatively, you can find the trap IDs from the trap coordinates using the `RegisterLayout.get_traps_from_coordinates()` method, which compares the provided coordinates with those on the layout with 6 decimal places of precision.\nsome_coords = layout.coords[\n    np.random.choice(np.arange(layout.number_of_traps), size=10, replace=False)\n]\ntrap_ids = layout.get_traps_from_coordinates(*some_coords)\nreg2 = layout.define_register(*trap_ids)\nreg2.draw()\n## Special Layouts\nfrom pulser.register.special_layouts import (\n    SquareLatticeLayout,\n    TriangularLatticeLayout,\n)\nOn top of the generic `RegisterLayout` class, there are special classes for common layouts that include convenience methods to more easily define a `Register`. These are subclasses of `RegisterLayout`, so all the methods specified above will still work.\n### `SquareLatticeLayout`\n`SquareLatticeLayout` specifies a layout from an underlying square lattice.\nsquare_layout = SquareLatticeLayout(7, 4, spacing=5)\nprint(square_layout)\nsquare_layout.draw()\nWith `SquareLatticeLayout.rectangular_register()` and `SquareLatticeLayout.square_register()`, one can conveniently define a new `Register`:\nsquare_layout.rectangular_register(rows=3, columns=4, prefix=\"a\").draw()\nsquare_layout.square_register(side=3).draw()\n### `TriangularLatticeLayout`\n`TriangularLatticeLayout` specifies a layout from an underlying triangular lattice.\ntri_layout = TriangularLatticeLayout(n_traps=100, spacing=5)\nprint(tri_layout)\ntri_layout.draw()\nWith `TriangularLatticeLayout.hexagonal_register()` or `TriangularLatticeLayout.rectangular_register()`, one can easily define a `Register` from a subset of existing traps.\ntri_layout.hexagonal_register(n_atoms=50).draw()\ntri_layout.rectangular_register(rows=3, atoms_per_row=7).draw()\n## Devices with pre-calibrated layouts\nfrom pulser.devices import Device\nfrom pulser.channels import Rydberg, Raman\n\nTestDevice = Device(\n    name=\"TestDevice\",\n    dimensions=2,\n    rydberg_level=70,\n    max_atom_num=100,\n    max_radial_distance=50,\n    max_layout_filling=0.4,\n    min_atom_distance=4,\n    channel_objects=(Rydberg.Global(2 * np.pi * 20, 2 * np.pi * 2.5),),\n    pre_calibrated_layouts=(\n        SquareLatticeLayout(10, 10, 4),\n        TriangularLatticeLayout(100, 5),\n    ),\n)\nWhen receiving a `Device` instance, it may include the layouts that are already calibrated and available to be used. To access them, simply run:\nTestDevice.calibrated_register_layouts\nYou can then choose one of these layouts to define your `Register` and start creating a `Sequence`:\nlayout = TestDevice.calibrated_register_layouts[\n    \"SquareLatticeLayout(10x10, 4.0\u00b5m)\"\n]\nreg = layout.square_register(6)\nseq = Sequence(reg, TestDevice)\nIn general, when a device comes with `pre_calibrated_layouts`, using them is encouraged. However, nothing prevents a `Sequence` to be created with a register coming from another layout, as long as that layout is compatible with the device. For example:\nanother_layout = SquareLatticeLayout(5, 5, 5)\nassert another_layout not in TestDevice.pre_calibrated_layouts\nreg_ = another_layout.square_register(3)\nseq = Sequence(reg_, TestDevice)\nHowever, it is not possible to use a register created from an invalid layout, even if the register is valid:\nbad_layout = TriangularLatticeLayout(\n    200, 10\n)  # This layout is too large for TestDevice\ngood_reg = bad_layout.hexagonal_register(\n    10\n)  # On its own, this register is valid in TestDevice\ntry:\n    seq = Sequence(good_reg, TestDevice)\nexcept ValueError as e:\n    print(e)\n### Maximum Layout Filling Fraction\nThrough the `Device.max_layout_filling`, a device also specifies how much a layout can be filled. Although the default value is 0.5, some devices might have slightly higher or lower values. \n\nIn the case of our `TestDevice`, we specified the maximum layout filling fraction to be 0.4 . This means that we can use up to 40% of a `RegisterLayout` to form our register.\n\nLet us see what would happen if we were to go over this value (e.g. by making a register of 49 atoms from a layout with 100 atoms):\nlayout = TestDevice.calibrated_register_layouts[\n    \"SquareLatticeLayout(10x10, 4.0\u00b5m)\"\n]\ntoo_big_reg = layout.square_register(7)\ntry:\n    seq = Sequence(too_big_reg, TestDevice)\nexcept ValueError as e:\n    print(e)\n## Mappable Registers\nFinally, layouts enable the creation of a `MappableRegister` \u2014 a register with the traps of each qubit still to be defined. This register can then be used to create a sort of parametrized `Sequence`, where deciding which traps will be mapped to which qubits only happens when `Sequence.build()` is called.\n\nFor example, below we define a mappable register with 10 qubits.\nmap_register = layout.make_mappable_register(n_qubits=10)\nmap_register.qubit_ids\nWe now use this register in our simple sequence:\nseq = Sequence(map_register, TestDevice)\nassert seq.is_register_mappable()\n\nseq.declare_channel(\"rydberg\", \"rydberg_global\")\nseq.add(\n    Pulse.ConstantPulse(duration=100, amplitude=1, detuning=0, phase=0),\n    \"rydberg\",\n)\nseq.draw()\nTo define the register, we can then call `Sequence.build()`, indicating in the `qubits` argument the map between qubit IDs and trap IDs. Note that not all the qubit IDs need to be associated to a trap ID, and that the qubit IDs have to be defined in their order of appearance in `MappableRegister.qubit_ids` (it is not possible to associate a trap ID to qubit ID \"q4\" if no trap ID was assigned to qubit ID \"q3\").\n\nIn this way, we can build multiple sequences, with only the `Register` changing from one to the other:\nseq1 = seq.build(qubits={\"q0\": 16, \"q1\": 19, \"q2\": 34})\nprint(\"First register:\", seq1.register.qubits)\n\nseq2 = seq.build(qubits={\"q0\": 0, \"q2\": 15, \"q1\": 20, \"q3\": 50})\nprint(\"Second register:\", seq2.register.qubits)", "params": {}}